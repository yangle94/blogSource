---
title: 业务操作数据库时的注意事项
date: 2017-04-07 10:32:18
tags: [Java,AutoCloseable]
---
# 一次数据库崩溃引发的思考
 前两天，因为写业务，操作数据库，因为sql不当操作，导致了数据库的崩溃，特此将其拿出进行反思和思考。

### 起因:
由于业务的原因，为了保留历史记录，所以我在删除的时候使用了delete_flag进行逻辑删除，所以，删除命令就变为了
    
    ```sql
	SELECT * FROM tableNmae WHERE delete_flag = 0
        UPDATE SET delete_flag = 1 FROM tableNmae = ?
    ```

### 分析
此时，虽然看似已经实现了程序所需要的功能，其实隐含着很大的问题。当数据库增加、删除频率以及数据库条数很大的时候，此问题会暴露的十分严重，甚至数据库的崩溃。

首先，我想说的是逻辑删除并非不可用，不过要切实配合好insert以及查询，保证数据库中的重复率不会太高。我当时的错误的做法：使用select语句对数据库中的数据进行存在检测，
如果不存在就增加一条，即SELECT * FROM tableNmae WHERE delete_flag = 0 -------》	INSERT INTO tableName () VALUES (),如果有数据，就跳过。删除时，直接调用
UPDATE SET delete_flag = 1 FROM tableNmae = ?。此时，如果删除、增加的数量一多，数据库中会存在非常多的已删除数据，并且在逻辑删除操作的时候，并未加入WHERE delete_flag = 0，
导致会将所有的已经逻辑删除的数据再次的删除一遍，数据量一大，直接会将数据库拉崩溃，我当时逻辑删除一条数据所占用的记录数基本到了1000条，在高峰时段直接导致了数据库崩溃。

### 解决之道：
针对此有几种解决方法:

1. 最简单的方法：将逻辑删除换为物理删除，这样无论会有多少次的重复加入数据，在累加的过程中只会保证一条未删除数据的存在。
2. 对逻辑删除加入WHERE delete_flag = 0 这个条件，用于减少一次性更新的条数。每次新增前查询数据库中是否存在对应的已经被删除相同数据，如果有，根据业务逻辑则逻辑删除其它未删除的数据，
然后将这条数据的删除位标识更改为0，如果没有在进行增加。

### 总结：
对于频繁的数据操作而言，一定要记得加入where条件使udpate语句更新最小的数量！！！！
